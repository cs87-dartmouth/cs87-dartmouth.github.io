<meta charset="utf-8"><!-- -*- markdown -*- -->
<style class="fallback">body{visibility:hidden}</style>

**Assignment 3: Textures**

**FIXME: add scenes using meshes (since BBH is already done now). add complex textured scenes. **

We will primarily be referring to chapters of [Ray Tracing - The Next Week](https://raytracing.github.io/books/RayTracingTheNextWeek.html) in this assignment. Make sure to grab a copy and read through it.

Make sure to do a `git pull` to retrieve any updates to the base code before you begin!

The `Texture` class (1 pt)
========================

Read [Ray Tracing - The Next Week: Chapter 4](https://raytracing.github.io/books/RayTracingTheNextWeek.html#solidtextures), and create a `Texture` base class following this chapter (perhaps in a new `texture.h` file within your `include/dirt` directory. Remember to add this file to the list of headers or source files in `CMakeLists.txt`). Instead of accepting `u`, `v`, and `p` parameters, we suggest you have your `Texture::value` function take a `const HitInfo &` as the parameter (you can then retrieve `u`, `v`, and `p` from within this `HitInfo`).

Constant textures
-----------------

Create a derived `class ConstantTexture : public Texture` which has a member variable `Color3f color;` and whose `value(...)` function just returns it. Make a constructor that takes a `const json &j` and tries to assign the parameter named "color" to your color member variable by using `j.value("color", color);`.

Retrofitting the parser
-----------------------

To make this work with the rest of Dirt, we need to refactor our code a bit so that `Materials` use `Texture`s instead of `Color3f`s, and so that it plays nice with our JSON parser. We will structure this based on how we already handle Materials in the code and JSON scene files.

Take a look at `include/dirt/material.h`. Each derived class has a constructor that accepts a `const json &`. In **FIXME** `parser.cpp,` the function `parseMaterial` takes a `json` object, reads the `"type"` to determine which material should be created, and calls the corresponding constructor with the `json` object. You should take a similar approach for handling `Texture`s. You can copy over `parseMaterial`, and create a `Texture` version of it; right now you only have one texture type, so return a `ConstantTexture` if the type is `"constant"`. If the type doesn't match any known texture type, you should return a default texture. You'll need to add a static `defaultTexture()` function to your Texture base class, and have this return a `ConstantTexture` with a color of your choice (look at how `defaultMaterial()` is implemented in `material.h/material.cpp` for inspiration). The default texture should only be used as a fallback if the scene refers to a texture type that doesn't exist, so make this default color something you'll notice during debugging (like a bright purple). An alternative would be to have the parser throw an exception if the scene refers to an undefined texture name, as `parseMaterial` currently does.

Now, change all the `Color3f` members of your `Material`s to `Texture`s, e.g. `Color3f albedo;` in `Lambertian` becomes `shared_ptr&lt;const Texture&gt; albedo.` You'll also need to change the corresponding constructors in `src/material.cpp` to call `parseTexture`, instead of reading a color directly from the passed `json` object, e.g. this:
    
~~~ C++
albedo = j.value("albedo", albedo);
~~~

becomes:

~~~ C++
albedo = parseTexture(j.at("albedo"));
~~~

You'll also want to support texturing the `Metal::roughness` parameter. This is currently a float, but you can still turn it into a `Texture`, and when calling its `value(...)` function, just convert to a scalar using the `luminance()` function in `include/dirt/vec.h`. An alternative approach would have been to treat color and grayscale textures separately, or allow roughness to differ across the three color channels, but we'll stick with the simpler approach.

Once you have this implemented, you should be able to render the scene `scenes/02_triangles_textures/constant-cornell-box.json`. This scene looks similar to the Cornell box from the previous assignment, except all albedos are now specified with a constant texture.

![](images/constant-cornell-box.png) 

Backwards scene compatibility
-----------------------------

One nuisance with our current solution is that we would have to re-write all our previous scene files (that directly specified a color) to instead use a "constant" texture. Previously we could have simply written:  

~~~ JSON
"albedo": [0.8, 1.0, 0.3],
~~~
in the scene file, but now we have to write the more clunky:  
~~~ JSON
"albedo":
{
    "type": "constant",
    "color": [0.8, 1.0, 0.3]
}
~~~

Let's add backwards compatibility so that the scene can specify colors directly too. To distinguish between these two forms, you can inspect the `const json &j` by calling `j.is_object()`, `j.is_array()` or `j.is_number()`.  **FIXME** In `parseTexture(...)` you should check whether `j` is an array or number, and create a `ConstantTexture` directly in these cases (you may also need to modify the `ConstantTexture` constructor to handle this). If `j` is an object, you can use your code from [1.2](#retrofittingtheparser) to construct the appropriate texture.

Once you have this implemented, you should be able to render all the scenes from the previous assignment. Give it a try.

Solid textures (2.5 pts)
========================

You now have the framework to easily add other types of textures, and these textures can be used any place you previously used a fixed `Color3f`! 

Checkerboard (1 pts)
--------------------

Add a CheckerTexture class following the description in [Section 4.3](https://raytracing.github.io/books/RayTracingTheNextWeek.html#solidtextures/acheckertexture) of the book, but adapted to the Dirt framework. Your constructor should look for fields named `"odd"` and `"even"` and use the **FIXME** `parseTexture` function you've already defined. You'll also need to extend your `parseTexture` function to handle this new type of texture.

Once you have this implemented, you should be able to render the scene `scenes/02_triangles_textures/checker.json` producing an image like the one below.

![](images/checker-ref.png)

Perlin noise (1.5 pts) **FIXME: OPTIONAL?**
----------------------

Read [Chapter 5](https://raytracing.github.io/books/RayTracingTheNextWeek.html#perlinnoise) of the book. Implement the `Perlin` class. Also implement the `noise_texture` class from the book, but call this `MarbleTexture` instead. Allow the JSON scene file to specify the `scale` member variable of your `MarbleTexture`, and instead of always interpolating between black and white as in the book, allow the user to specify these two colors in the JSON scene file just like we did with `"odd"` and `"even"` for the checkerboard. Look for the named fields `"veins"` and `"base"` in the JSON object for this purpose.

Render `scenes/02_triangles_textures/marble.json`.

![](images/marble-128spp.png)

Image texture mapping (2.5 pts)
===============================

The `ImageTexture` class (1 pts)
------------------------------

Read [Chapter 6](https://raytracing.github.io/books/RayTracingTheNextWeek.html#imagetexturemapping) of the book and implement image texturing mapping. We already provide you with image loading support, which you should leverage using the `Image3f` class defined in `include/dirt/image.h` and `src/image.cpp`. Your `ImageTexture` class should accept a `"filename"` string parameter from the `json` object. Once you read this string, use the global file resolver to resolve this filename into a path, like so:

~~~ C++
string path = get_file_resolver().resolve(filename).str();
~~~

`get_file_resolver()` is defined in `include/dirt/common.h`.


Texture coordinates (1.5 pts)
-----------------------------

Extend your `Sphere::intersect` function to output the UV coordinates as [described in the book](https://raytracing.github.io/books/RayTracingTheNextWeek.html#solidtextures/texturecoordinatesforspheres).

You should now be able to render `scenes/02_triangles_textures/earth.json`

![](images/earth-ref.png)

Now, extend your `Quad::intersect` function to output UV coordinates. Render `scenes/02_triangles_textures/textured-box.json`. 

![](images/textured-box-ref.png)

**FIXME** Finally, extend `Triangle::intersect` to output UV coordinates. You will need to extend `single_triangle_intersect` to take three `Vec2f` pointers (the uv coordinates for each vertex), in addition to the positions and normals. As with the normals, if the mesh doesn't provide per-vertex UV coorinates, we'll need to fall back to some reasonable default. In this case, you should just store the barycentric coordinates in place of interpolated UV coordinates.

If you render `scenes/02/triangles_textures/teapot.json` you should see a scene with a teapot mesh that has texture coordinates and a texture applied, as shown below.

![](images/teapot-ref.png)

Blend material (1 pts)
======================

**FIXME: make this FresnelBlend** Now let's create a `BlendMaterial` that is a blend between two other materials. This material should store two `shared_ptrs` to `Materials` (specified as `"a"` and `"b"` in the JSON file), and a `shared_ptr` to a `Texture` (`"amount"` in JSON) specifying the amount of blend between "a" and "b". You'll need to update the parser to support this material type.

In the `scatter()` function, you will need to evaluate the blend amount texture, convert this value to a scalar (e.g. using `luminance()`) and then draw a random number using `randf()`. If `randf()` is less than the blend amount, then call the `scatter()` function of material b, otherwise, call the `scatter()` function of material a.

Render `scenes/02_triangles_textures/blend.json`.

![](images/blend-ref.png)

Interesting scene (2 pts)
=========================

Now create an interesting scene (or scenes) showcasing all the features you've implemented. Be creative. Find some interesting textures online, or create some new procedural textures by combining your existing functionality. Consider applying textures to various parts of a material, like the blend factor, the roughness, and emission.

What to submit
==============

**Please read the following instructions carefully: Include the required files and nothing else. Do not pack the required files into a containing folder, just zip the files directly.**

Please edit the `report/report.html` report template and fill in your feedback, comments and optional explanations. Add a section for each task. If a task provides a reference image, please include a comparison between the image produced by your code and the reference (the template shows you how to do this easily).

Upload a zip file containing

*   The source code (the entire _include_ and _src_ folders)
*   Your interesting scene
*   Rendered images of all the scenes in _scenes/02_triangles_textures_ and your interesting scene
*   The `report` folder.

**Do not submit any binaries. Do not include your build folder in the zip file. Do not put the required files/folders into a containing folder; zip them directly and submit the zip file.**

<script>
markdeepOptions = {tocStyle: 'medium'};
</script>


<script src="../js/common.js"></script>
